% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute-handles.R
\name{compute_handles}
\alias{compute_handles}
\title{Construct Bezier control points from a sequence of positions}
\usage{
compute_handles(
  points,
  method = c("catmull", "linear", "normal", "tangent"),
  tension = 0.3,
  scale = 0.3,
  side = c("left", "right")
)
}
\arguments{
\item{points}{A \code{k * 2} matrix or data frame of points. Each row is \verb{(x, y)}.}

\item{method}{Handle–generation strategy. One of
\code{"catmull"}, \code{"linear"}, \code{"normal"}, \code{"tangent"}.}

\item{tension}{Numeric scaling factor for \code{"linear"} method (default \code{0.3}).}

\item{scale}{Numeric scaling factor for \code{"normal"} and \code{"tangent"} methods
(default \code{0.3}).}

\item{side}{For \code{"normal"} method, choose \code{"left"} or \code{"right"} to determine
the orientation of the normal vector.}
}
\value{
A tibble with columns
\verb{x0, y0, x1, y1, x2, y2, x3, y3},
containing one Bezier segment per row.
}
\description{
Generates cubic Bezier control points from an ordered sequence of 2D points.
Given a \code{k * 2} matrix (or data frame) of points \eqn{P_0, P_1, \dots, P_{k-1}},
this function returns a tibble representing a set of Bezier segments.
Each output row encodes one cubic Bezier curve segment with control points
\verb{(x0, y0, x1, y1, x2, y2, x3, y3)}, forming a curve from \code{P_i} to \verb{P_\{i+1\}}.

Different handle–generation strategies can be selected via \code{method}.
}
\details{
These helper functions are intended to be used together with
\code{\link[=curve_bezier]{curve_bezier()}} and the vector–field functions
\code{\link[=bezier_tangent]{bezier_tangent()}}, \code{\link[=bezier_normal]{bezier_normal()}}, and \code{\link[=bezier_derivative]{bezier_derivative()}}.
They are useful for smoothing polyline data, constructing interpolating
curves, and generating stylized shapes for creative coding.
\subsection{\code{method = "catmull"}}{

Uses Catmull–Rom spline to construct smooth Bezier segments.
For each segment \eqn{P_i \to P_{i+1}}, interior points are computed as:
\deqn{
   B_1 = P_i     + (P_{i+1} - P_{i-1}) / 6,\quad
   B_2 = P_{i+1} - (P_{i+2} - P_i)     / 6.
 }
Produces \code{k - 3} segments (requires 4 or more points).
}

\subsection{\code{method = "linear"}}{

Places both handles along the segment direction.
Handles are spaced from the endpoints by \verb{tension * distance(P_i, P_\{i+1\})}.
Produces \code{k - 1} straight-style Bezier segments.
}

\subsection{\code{method = "normal"}}{

Handles are placed perpendicular to the segment direction, producing
decorative, "bent" or "blooming" curves.
The handle offset is \eqn{\text{scale} \times \| P_{i+1} - P_i \|}.
Use \code{side = "left"} or \code{"right"} to control the normal direction.
}

\subsection{\code{method = "tangent"}}{

Computes tangents using centered differences, giving a smooth,
spline-like interpolation.
The handle offset is \eqn{\text{scale} \times \| P_{i+1} - P_i \|}.
Produces \code{k - 1} \eqn{C^1}–continuous Bezier segments.
}
}
\examples{
pts <- matrix(rnorm(20), ncol = 2)

# Tangent-based smoothing
segs <- compute_handles(pts, method = "tangent")
curve_bezier(n = 50, segs)
}
\seealso{
\code{\link[=curve_bezier]{curve_bezier()}}
}
